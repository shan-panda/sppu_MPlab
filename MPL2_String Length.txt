Write an ALP to accept a string and to display it’s length.

section .data
	msg db 'Enter String:',10
	msgLen:equ $-msg
	
	msg2 db 'You entered:'
	msg2len:equ $-msg2
	
	msg3 db 'Your string size:'
	msg3len:equ $-msg3
	
	
section .bss
	buffer resb 50
	buffer_size:equ $-buffer
	count resd 1
	dcnt resb 1
	buffer_num resd 1 
	dispnum resb 8

section .text
	global _start
	

	_start:				;'Enter String' msg display
		mov eax,4
		mov ebx,1
		mov ecx, msg
		mov edx, msgLen
		int 80h

	read:
		mov eax, 3			;system call for reading input
		mov ebx, 0			;system call for store string in 						;to varible
		mov ecx, buffer		;store the string into buffer 							;variable
		mov edx, buffer_size	;store the string size into 								;buffer_size variable
		int 80h

		mov [count], eax		;store the string into 								;count variable in array 								;format
	
						;'You Entered' msg display
		mov eax, 4
		mov ebx, 1
		mov ecx, msg2
		mov edx, msg2len
		int 80h

		mov eax, 4		;system call for write input
		mov ebx, 1		;system call for file descriptor
		mov ecx, buffer		;locate string into ecx
		mov edx, [count]	;locate size of string into edx
		int 80h

					;'Your string size:' msg display
		mov eax, 4
		mov ebx, 1
		mov ecx, msg3
		mov edx, msg3len
		int 80h

	
		mov esi,dispnum+7	;load last byte address of 							;dispnum buffer in esi
		mov eax,[count]		;load value at count in eax
		mov ecx,8		;number of digits
		dec eax

	cnt:	mov edx,0		;make edx=0 (as in div instruction 						;edx:eax/ebx)
		mov ebx,10		;divisor=10
		div ebx
		add dl,30h		;calculate ASCII code
		mov [esi],dl		;store it in buffer
		dec esi			;point to one byte back
		loop cnt
		dec ecx			;decrement count
		jnz cnt			;if not zero repeat

	up1:	mov eax,4		;system call for write input
		mov ebx,1		;system call for file descriptor
		mov ecx,dispnum		;locate string into ecx
		mov edx,8		;locate size of string into edx
		int 80h

	exit:	mov eax,1
		mov ebx,0
		int 80h
